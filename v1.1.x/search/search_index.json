{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Documentation","text":"<p>This is the documentation for ArunaAPI version 1.1.x.</p> <p>Updated... again.</p>"},{"location":"about/","title":"Iubasque nunc fit novum precibusque quod","text":""},{"location":"about/#se-crus-animalia-luridus-amari-citius-velare","title":"Se crus animalia luridus amari citius velare","text":"<p>Lorem markdownum trepidant, ante egressa; imponit Troia, sed iam: fulmina. Baca quod parvo, harundinibus quid reliquit pastorve seniles da lenius fortis: orbem dumque: possem.</p> <ol> <li>Osque venerat incubat in deae cancro conpescit</li> <li>Audire paternos rudis</li> <li>Avernales vicimus sunt iungat selige</li> <li>Nec coeptaeque legum</li> </ol>"},{"location":"about/#terris-potes-vocat-erravit","title":"Terris potes vocat erravit","text":"<p>Recentia fuerat silva, tacui, hic ab eiaculatus inter munere flectere sacro. Gemit inpar montes valuere fulva sub, ab vadit Acoete dolorque vetitae et totiens inficit vocem tellus signum obsessa: ipse? Non potest ambo duram incendia.</p> <p>Foliis poenaeque meriti uberior Vertumnus mundo serisque, Atlantiades astu: dabunt et mihi urnam. Iovis primo tum terrore matrem huic: tamen iste ultima illum certaminis! Ungues servo, fuerat, traiectus sed esse palustribus deam, et usquam fertur amor Antiphates. Cultusque vultus ferre iussis, secura quasque.</p>"},{"location":"about/#gentis-fecundaque-iuvenes-ferasque-gentis-patrios-postquam","title":"Gentis fecundaque iuvenes ferasque gentis patrios postquam","text":"<p>Iura bene inpellitur inplevere edidit mali vocibus. Hoc nefandis gravitate tandem Pandione properatis mansit, ut petis Pontum seu cortice vocalis, potest nec dici costis.</p> <p>Ibi Solis auras est Clymeni maxima, cum quod laceraret alii; duo ante data! Fratrem pedum mihi posset quo vitibus fores in non properamus, obit, cum qui admonuisse medios, fuit. Caede non. Ver honorem tutius tutaque, tendit nec cur tulere haec talis crescit, qua vult nunc queri arentia haerebis.</p> <p>Genitore cupiasque viribus, per crimine seque vulnere causa vulnere mihi est, est qua servent. Miratur circumspice tectaque est, Ulixis sint redimebat et motus incautum arserunt: Cupido inque. Voce iniectos rudentes o domito ulterius, stantes fiat, sic litem et est accipite Pactolides grani, hic. Spinas parvae; a eburno nemus nisi volenti sponte huius vigil laudis saeviat et luna. Conata versant venatu!</p> <p>Fuit Proteu victos et canor accendere furit principium olim, parere reparet ut mora? Medios Cerastae sunto, esse Spercheides laudabat toto barba credunt pallor garrula. In caelum caduca pyram classe digna paelicis lora, tenebant dantur et. Narres quisquam vacant.</p>"},{"location":"deployment/instance_deployment/","title":"AOS Instance Deployment","text":""},{"location":"deployment/instance_deployment/#introduction","title":"Introduction","text":"<p>Lorem ipsum dolor.</p>"},{"location":"get_started/get_started/","title":"Get Started Bitches","text":""},{"location":"get_started/get_started/#api-examples-for-everyone","title":"API Examples for everyone","text":"<p>This is a link to the ... whatever</p>"},{"location":"get_started/basic_usage/01_Get-Storage-Access/","title":"Get Storage Access","text":""},{"location":"get_started/basic_usage/01_Get-Storage-Access/#introduction","title":"Introduction","text":"<p>For the general access a registered account within the official NFDI/NFDI4Biodiversity/GFBio AAI is needed to obtain a valid OIDC token from one of those.</p> <p>After login, you can use your OIDC token to register yourself at an AOS instance.  To create/modify resources within the given scope/permissions you have to generate API token(s) after you have been activated by an administrator.</p> <p>Please note that these following tutorials cover only the most basic operations.  For a complete list of the public API endpoints, their matching requests and responses, please refer to our Aruna Object Storage REST API Swagger-UI.</p> <p>Let's get started!</p>"},{"location":"get_started/basic_usage/01_Get-Storage-Access/#client-creation","title":"Client Creation","text":"<p>If you plan to send your requests through an application the first step is to open a connection to the server you want to send the requests to.</p> <p>Note: This is a minimal reproducible example which should not be used 'as-is' in a production environment...</p> RustGoPythonJava <pre><code>use aruna_rust_api::api::aruna::api::storage::services::v1::{\nuser_service_client,\nproject_service_client,\ncollection_service_client,\nobject_service_client,\nobject_group_service_client,\n}\nuse std::sync::Arc;\nuse tonic::codegen::InterceptedService;\nuse tonic::metadata::{AsciiMetadataKey, AsciiMetadataValue};\nuse tonic::transport::{Channel, ClientTlsConfig};\n// Create a client interceptor which always adds the specified api token to the request header\n#[derive(Clone)]\npub struct ClientInterceptor {\napi_token: String,\n}\n// Implement a request interceptor which always adds \n//  the authorization header with a specific API token to all requests\nimpl tonic::service::Interceptor for ClientInterceptor {\nfn call(&amp;mut self, request: tonic::Request&lt;()&gt;) -&gt; Result&lt;tonic::Request&lt;()&gt;, tonic::Status&gt; {\nlet mut mut_req: tonic::Request&lt;()&gt; = request;\nlet metadata = mut_req.metadata_mut();\nmetadata.append(\nAsciiMetadataKey::from_bytes(\"Authorization\".as_bytes()).unwrap(),\nAsciiMetadataValue::try_from(format!(\"Bearer {}\", self.api_token.as_str())).unwrap(),\n);\nreturn Ok(mut_req);\n}\n}\nfn main() {\n// Create connection to AOS instance gRPC gateway\nlet api_token   = \"MySecretArunaApiToken\".to_string();\nlet tls_config  = ClientTlsConfig::new();\nlet endpoint    = Channel::from_shared(\"https://&lt;URL-To-AOS-Instance-gRPC-Gateway&gt;\").unwrap().tls_config(tls_config).unwrap();\nlet channel     = endpoint.connect().await.unwrap();\nlet interceptor = ClientInterceptor { api_token: api_token.clone() };\n// Create the individual client services\nlet mut user_client         = user_service_client::UserServiceClient::with_interceptor(channel.clone(), interceptor.clone());\nlet mut project_client      = project_service_client::ProjectServiceClient::with_interceptor(channel.clone(), interceptor.clone());\nlet mut collection_client   = collection_service_client::CollectionServiceClient::with_interceptor(channel.clone(), interceptor.clone());\nlet mut object_client       = object_service_client::ObjectServiceClient::with_interceptor(channel.clone(), interceptor.clone());\nlet mut object_group_client = object_group_service_client::ObjectGroupServiceClient::with_interceptor(channel.clone(), interceptor.clone());\n// Do something with the client services ...\n}\n</code></pre> <pre><code>Coming Soon ...\n</code></pre> <pre><code>Coming Soon ...\n</code></pre> <pre><code>Coming Soon ...\n</code></pre> <p>The presence of a client connection to the specific resource service is required for all further requests in this tutorial if the requests are send via gRPC.</p>"},{"location":"get_started/basic_usage/01_Get-Storage-Access/#user-registration","title":"User registration","text":"<p>Users can register themselves in an AOS instance with their valid OIDC token received from the AAI login.</p> BashRustPython <pre><code># Native JSON request to register OIDC user\ncurl -d '\n  {\n    \"display_name\": \"Forename Surname\"\n  }' \\\n-H \"Authorization: Bearer &lt;OIDC_TOKEN&gt;\" \\\n-H \"Content-Type: application/json\" \\\n-X POST https://&lt;URL-to-AOS-instance-API-gateway&gt;/v1/auth/register\n</code></pre> <pre><code>// Create tonic/ArunaAPI request to register OIDC user\nlet register_request = RegisterUserRequest {\ndisplay_name: \"John Doe\".to_string(),\n};\n// Send the request to the AOS instance gRPC gateway\nlet response = user_client.register_user(register_request)\n.await\n.unwrap()\n.into_inner();\n// Do something with the response\nprintln!(\"Registered user: {:#?}\", response.user_id)\n</code></pre> <pre><code>Coming Soon ...\n</code></pre>"},{"location":"get_started/basic_usage/01_Get-Storage-Access/#user-activation","title":"User activation","text":"<p>After registration users additionally have to be activated in a second step. Activation can only be performed by an AOS instance administrator.</p> BashRust <pre><code># For convenience, administrators can request info on all unactivated users at once\ncurl -H \"Authorization: Bearer &lt;API-Or-OIDC_TOKEN&gt;\" \\\n-H \"Content-Type: application/json\" \\\n-X GET https://&lt;URL-to-AOS-instance-API-gateway&gt;/v1/user/not_activated\n</code></pre> <pre><code># Native JSON request to activate registered user\ncurl -H \"Authorization: Bearer &lt;API-Or-OIDC_TOKEN&gt;\" \\\n-H \"Content-Type: application/json\" \\\n-X PATCH https://&lt;URL-to-AOS-instance-API-gateway&gt;/v1/user/&lt;user-id&gt;/activate\n</code></pre> <pre><code>// Create tonic/ArunaAPI request to fetch all not activated users\nlet get_request = GetNotActivatedUsersRequest {};\n// Send the request to the AOS instance gRPC gateway\nlet unactivated = user_client.get_not_activated_users(request)\n.await\n.unwrap()\n.into_inner();\n// Do something with the response\nprintln!(\"{:#?}\", unactivated);\n</code></pre> <pre><code>// Create tonic/ArunaAPI request for user activation\nlet user_id = uuid::Uuid::parse(\"12345678-1234-1234-1234-123456789999\").unwrap();\nlet activate_request = ActivateUserRequest {\nuser_id: user_id.to_string()\n};\n// Send the request to the AOS instance gRPC gateway\nlet activate_response = user_client.activate_user(activate_request)\n.await\n.unwrap()\n.into_inner();\n// Do something with the response\nprintln!(\"Activated user: {:#?}\", activate_response.user_id)\n</code></pre>"},{"location":"get_started/basic_usage/01_Get-Storage-Access/#who-am-i-what-am-i","title":"Who Am I / What Am I","text":"<p>To check which user a token is associated with or get information about the current users permissions, you can use the UserService API.</p> <p>Only AOS instance administrators can request user information of other users.</p> BashRust <pre><code># Native JSON request to fetch user information associated with authorization token\ncurl -H \"Authorization: Bearer &lt;API-Or-OIDC_TOKEN&gt;\" \\\n-H \"Content-Type: application/json\" \\\n-X GET https://&lt;URL-to-AOS-instance-API-gateway&gt;/v1/user\n</code></pre> <pre><code># Native JSON request to fetch user information associated with the provided user id\ncurl -H \"Authorization: Bearer &lt;API-Or-OIDC_TOKEN&gt;\" \\\n-H \"Content-Type: application/json\" \\\n-X GET https://&lt;URL-to-AOS-instance-API-gateway&gt;/v1/user?userId=&lt;user-id&gt;\n</code></pre> <pre><code>// Create tonic/ArunaAPI request to fetch user info of current user\nlet get_request = GetUserRequest {\nuser_id: \"\".to_string()\n};\n// Send the request to the AOS instance gRPC gateway\nlet response = user_client.get_user(get_request)\n.await\n.unwrap()\n.into_inner();\n// Do something with the response\nprintln!(\"Received permission info for user: {:#?}\", response.user);\nprintln!(\"Received project permissions:\");\nfor permission in response.project_permissions {\nprintln!(\"{:#?}\", permission);\n}\n</code></pre>"},{"location":"get_started/basic_usage/02_How-To-Auth-Tokens/","title":"How to deal with tokens and permissions","text":""},{"location":"get_started/basic_usage/02_How-To-Auth-Tokens/#introduction","title":"Introduction","text":"<p>The only actions that can be executed with your OIDC token are the user registration, fetching user info and API token creation/deletion.</p> <p>For every action afterwards inside the AOS the user needs a generated API token with sufficient permissions. Permissions can be granted either through scoped API tokens for projects or collections themselves or through user specific permissions which will be enforced by a global/personal token.</p>"},{"location":"get_started/basic_usage/02_How-To-Auth-Tokens/#generate-api-token","title":"Generate API token","text":"<p>An API token can be created with different scopes and/or different permissions.</p>"},{"location":"get_started/basic_usage/02_How-To-Auth-Tokens/#available-token-permissions","title":"Available token permissions:","text":"<ul> <li><code>NONE</code> (\"PERMISSION_NONE\"): No permissions granted</li> <li><code>READ</code> (\"PERMISSION_READ\"): Read only access</li> <li><code>APPEND</code> (\"PERMISSION_APPEND\"): Can create new resources but cannot modify existing</li> <li><code>MODIFY</code> (\"PERMISSION_MODIFY\"): Can create new resources and modify existing</li> <li><code>ADMIN</code> (\"PERMISSION_ADMIN\"): Can create new resources, modify existing and additionally delete</li> </ul> <p>So when we talk about minimum requirements for authorization, we get the following order: <code>ADMIN &gt; MODIFY &gt; APPEND &gt; READ</code></p>"},{"location":"get_started/basic_usage/02_How-To-Auth-Tokens/#available-api-token-scopes","title":"Available API token scopes:","text":"<ul> <li>Global/Personal:</li> </ul> <p>The fields <code>projectId</code> and <code>collectionId</code> are empty on creation. This token is valid with nearly every request and inherits the permissions which are set user-specific on projects. </p> <p>For example, when a user is added to a project with READ permission, this token \"inherits and enforces\" the user's READ permission with every request regarding the project or its resources.</p> <ul> <li>Project: </li> </ul> <p>The field <code>projectId</code> is filled and the field <code>collectionId</code> is empty. This token is valid for the specific Project and all the resources which are associated with it.</p> <p>These tokens can be used to give general access to a Project and all resources registered under it, however, should not be distributed carelessly.</p> <ul> <li>Collection: </li> </ul> <p>The field <code>collectionId</code> is filled and the field <code>projectId</code> is empty. This token is valid only for the specific Collection and its containing Objects/ObjectGroups. </p> <p>These tokens can be used to give users access to a more specific selection of Collections.</p>"},{"location":"get_started/basic_usage/02_How-To-Auth-Tokens/#add-users-to-project","title":"Add users to Project","text":"<p>Users can be granted specific permissions for projects, which are inherited and enforced by their global/personal tokens.  This makes it easy to add users to projects without them having to create an additional token per project or even collection.  It also makes it easy to restrict or extend a user's permissions for a project without having to revoke, re-generate and/or re-distribute tokens.</p> <p>This request needs at least ADMIN permissions on the specific Project.</p> BashRust <pre><code># Native JSON request to add user with admin permissions to a project\ncurl -d '\n  {\n    \"userPermission\": {\n      \"userId\": \"&lt;user-id&gt;\",\n      \"projectId\": \"&lt;project-id&gt;\",\n      \"permission\": \"PERMISSION_ADMIN\"\n    }\n  }' \\\n-H 'Authorization: Bearer &lt;API_TOKEN&gt;' \\\n-H 'Content-Type: application/json' \\\n-X POST https://&lt;URL-to-AOS-instance-API-gateway&gt;/v1/project/&lt;project-id&gt;/add_user\n</code></pre> <pre><code># Native JSON request to add user with read only permissions to a project\ncurl -d '\n  {\n    \"userPermission\": {\n      \"userId\": \"&lt;user-id&gt;\",\n      \"projectId\": \"&lt;project-id&gt;\",\n      \"permission\": \"PERMISSION_READ\"\n    }\n  }\n' \\\n-H 'Authorization: Bearer &lt;API_TOKEN&gt;' \\\n-H 'Content-Type: application/json' \\\n-X POST https://&lt;URL-to-AOS-instance-API-gateway&gt;/v1/project/&lt;project-id&gt;/add_user\n</code></pre> <pre><code>// Create tonic/ArunaAPI request to add user with admin permissions to a project\nlet add_request = AddUserToProjectRequest {\nproject_id: \"&lt;project-id&gt;\".to_string(),\nuser_permission: Some(ProjectPermission {\nuser_id: \"&lt;user-id&gt;\".to_string(),\ndisplay_name: \"\".to_string(),\nproject_id: \"&lt;project-id&gt;\".to_string(),\npermission: Permission::Admin as i32,\n}),\n};\n// Send the request to the AOS instance gRPC gateway\nlet response = project_client.add_user_to_project(add_request)\n.await\n.unwrap()\n.into_inner();\n// Do something with the response\nprintln!(\"{:#?}\", response);\n</code></pre> <pre><code>// Create tonic/ArunaAPI request to add user with read only permissions to a project\nlet add_request = AddUserToProjectRequest {\nproject_id: \"&lt;project-id&gt;\".to_string(),\nuser_permission: Some(ProjectPermission {\nuser_id: \"&lt;user-id&gt;\".to_string(),\ndisplay_name: \"\".to_string(),\nproject_id: \"&lt;project-id&gt;\".to_string(),\npermission: Permission::Read as i32,\n}),\n};\n// Send the request to the AOS instance gRPC gateway\nlet response = project_client.add_user_to_project(add_request)\n.await\n.unwrap()\n.into_inner();\n// Do something with the response\nprintln!(\"{:#?}\", response);\n</code></pre>"},{"location":"get_started/basic_usage/02_How-To-Auth-Tokens/#edit-project-user-permission","title":"Edit Project user permission","text":"<p>The assigned permissions to the users can be changed by project administrators afterwards.</p> <p>This request needs at least ADMIN permissions on the specific Project.</p> BashRust <pre><code># Native JSON request to add user with admin permissions to a project\ncurl -d '\n  {\n    \"userPermission\": {\n      \"userId\": \"&lt;user-id&gt;\",\n      \"projectId\": \"&lt;project-id&gt;\",\n      \"permission\": \"PERMISSION_READ\"\n    }\n  }' \\\n-H 'Authorization: Bearer &lt;API_TOKEN&gt;' \\\n-H 'Content-Type: application/json' \\\n-X POST https://&lt;URL-to-AOS-instance-API-gateway&gt;/v1/project/&lt;project-id&gt;/edit_user\n</code></pre> <pre><code>// Create tonic/ArunaAPI request to set a users permission to read-only for the specific project\nlet edit_request = EditUserPermissionsForProjectRequest {\nproject_id: \"&lt;project-id&gt;\".to_string(),\nuser_permission: Some(ProjectPermission {\nuser_id: \"&lt;user-id&gt;\".to_string(),\ndisplay_name: \"\".to_string(),\nproject_id: \"&lt;project-id&gt;\".to_string(),\npermission: Permission::Read as i32,\n}),\n};\n// Send the request to the AOS instance gRPC gateway\nlet response = project_client.edit_user_permissions_for_project(edit_request)\n.await\n.unwrap()\n.into_inner();\n// Do something with the response\nprintln!(\"{:#?}\", response);\n</code></pre>"},{"location":"get_started/basic_usage/02_How-To-Auth-Tokens/#remove-project-user","title":"Remove Project user","text":"<p>Users can, of course, also be completely removed from projects again, depriving them of any access with personalized tokens.  However, access with project/collection scoped tokens is not restricted with the removal of the user.</p> <p>This request needs at least ADMIN permissions on the specific Project.</p> BashRust <pre><code># Native JSON request to remove a user from a specific project\ncurl -H 'Authorization: Bearer &lt;API_TOKEN&gt;' \\\n-H 'Content-Type: application/json' \\\n-X POST https://&lt;URL-to-AOS-instance-API-gateway&gt;/v1/project/&lt;project-id&gt;/remove_user?userId=&lt;user-id&gt;\n</code></pre> <pre><code>// Create tonic/ArunaAPI request to remove a user from a specific project\nlet delete_request = RemoveUserFromProjectRequest {\nproject_id: \"&lt;project-id&gt;\".to_string(),\nuser_id: \"&lt;user-id&gt;\".to_string(),\n};\n// Send the request to the AOS instance gRPC gateway\nlet response = project_client.remove_user_from_project(edit_request)\n.await\n.unwrap()\n.into_inner();\n// Do something with the response\nprintln!(\"{:#?}\", response);\n</code></pre>"},{"location":"get_started/basic_usage/02_How-To-Auth-Tokens/#generate-api-tokens","title":"Generate API Tokens","text":"<p>Here are some API examples on generating API tokens with individual scopes and permissions.</p> <p>The token secret is only available once in the response and cannot be re-generated!</p> <p>Store the received token secret in a secure location for further usage. If a token secret is lost or compromised, delete the old token and generate a new one.</p> BashRust <pre><code># Native JSON request to create a global/personal token\n#  This token inherits the permissions from the projects the user is a member of\ncurl -d '\n  {\n    \"projectId\": \"\",\n    \"collectionId\": \"\",\n    \"name\": \"MyPersonalToken\",\n    \"expiresAt\": {\n      \"timestamp\": \"2023-01-01T00:00:00.000Z\"\n    }\n  }' \\\n-H 'Authorization: Bearer &lt;OIDC-or-API_token' \\\n-H 'Content-Type: application/json' \\\n-X POST https://&lt;URL-to-AOS-instance-API-gateway&gt;/v1/auth/token\n</code></pre> <pre><code># Native JSON request to create a project scoped token with MODIFY permissions\ncurl -d '\n  {\n    \"projectId\": \"&lt;project-id&gt;\",\n    \"collectionId\": \"\",\n    \"name\": \"Project-Modify-Token\",\n    \"expiresAt\": {\n      \"timestamp\": \"2023-01-01T00:00:00.000Z\"\n    },\n    \"permission\": \"PERMISSION_MODIFY\"\n  }' \\\n-H 'Authorization: Bearer &lt;OIDC-Or-API_TOKEN&gt;' \\\n-H 'Content-Type: application/json' \\\n-X POST https://&lt;URL-to-AOS-instance-API-gateway&gt;/v1/auth/token\n</code></pre> <pre><code># Native JSON request to create a collection scoped token with READ permissions\ncurl -d '\n  {\n    \"projectId\": \"\",\n    \"collectionId\": \"&lt;collection-id&gt;\",\n    \"name\": \"Collection-ReadOnly-Token\",\n    \"expiresAt\": {\n      \"timestamp\": \"2023-01-01T00:00:00.000Z\"\n    },\n    \"permission\": \"PERMISSION_READ\"\n  }' \\\n-H 'Authorization: Bearer &lt;OIDC-Or-API_TOKEN&gt;' \\\n-H 'Content-Type: application/json' \\\n-X POST https://&lt;URL-to-AOS-instance-API-gateway&gt;/v1/auth/token\n</code></pre> <p>The \"in-line\" conversion of a NativeDateTime to a gRPC Timestamp is kind of hacky. In any case it is recommended to implement the <code>From&lt;NativeDateTime&gt;</code> or <code>TryFrom&lt;NativeDateTime&gt;</code> trait for the Timestamp Struct.</p> <pre><code>```rust\n// Create tonic/ArunaAPI request to create a global/personal API token with expiration\nlet expires_at = NaiveDate::from_ymd(2023, 01, 01).and_hms(0, 0, 0);\nlet create_request = CreateApiTokenRequest {\n    project_id: \"\".to_string(), \n    collection_id: \"\".to_string(),\n    name: \"MyPersonalToken\".to_string(),\n    expires_at: Some(ExpiresAt {\n        timestamp: Some(\n            Timestamp::date_time(\n                expires_at.date().year().into(),\n                expires_at.date().month() as u8,\n                expires_at.date().day() as u8,\n                expires_at.time().hour() as u8,\n                expires_at.time().minute() as u8,\n                expires_at.time().second() as u8,\n            ).unwrap(), \n        ),\n    }),\n    permission: Permission::None as i32,\n};\n\n// Send the request to the AOS instance gRPC gateway\nlet response = user_client.create_api_token(create_request)\n                          .await\n                          .unwrap()\n                          .into_inner();\n\n// Do something with the response\nprintln!(\"{:#?}\", response);\n```\n</code></pre>"},{"location":"get_started/basic_usage/02_How-To-Auth-Tokens/#get-api-tokens","title":"Get API token(s)","text":"<p>API examples to fetch info of a specific token or all tokens of the current user.</p> <p>This request does not re-display the generated API token secret.</p> BashRust <pre><code># Native JSON request to get info on a specific API token by its id\ncurl -H 'Authorization: Bearer &lt;OIDC-Or-API_TOKEN&gt;' \\\n-H 'Content-Type: application/json' \\\n-X GET https://&lt;URL-to-AOS-instance-API-gateway&gt;/v1/auth/token/{token-id}\n</code></pre> <pre><code># Native JSON request to get info on all tokens associated with the current user\ncurl -H 'Authorization: Bearer &lt;OIDC-Or-API_TOKEN&gt;' \\\n-H 'Content-Type: application/json' \\\n-X GET https://&lt;URL-to-AOS-instance-API-gateway&gt;/v1/auth/tokens\n</code></pre> <pre><code>// Create tonic/ArunaAPI request to get info on a specific API token by its id\nlet get_request = GetApiTokenRequest { token_id: \"&lt;token-id&gt;\".to_string(),\n};\n// Send the request to the AOS instance gRPC gateway\nlet response = user_client.get_api_token(get_request)\n.await\n.unwrap()\n.into_inner();\n// Do something with the response\nprintln!(\"{:#?}\", response);\n</code></pre> <pre><code>// Create tonic/ArunaAPI request to get info on all tokens associated with the current user\nlet get_request = GetApiTokensRequest {};\n// Send the request to the AOS instance gRPC gateway\nlet response = user_client.get_api_tokens(get_request)\n.await\n.unwrap()\n.into_inner();\n// Do something with the response\nprintln!(\"{:#?}\", response);\n</code></pre>"},{"location":"get_started/basic_usage/02_How-To-Auth-Tokens/#revoke-tokens","title":"Revoke token(s)","text":"<p>API examples to revoke/delete a specific API token or all tokens of the current user.</p> <p>Only AOS instance administrators can revoke API tokens of other users.</p> BashRust <pre><code># Native JSON request to revoke the specific API token\ncurl -H 'Authorization: Bearer &lt;OIDC-Or-API_TOKEN&gt;' \\\n-H 'Content-Type: application/json' \\\n-X DELETE https://&lt;URL-to-AOS-instance-API-gateway&gt;/v1/auth/token/{token-id}\n</code></pre> <pre><code># Native JSON request to revoke all tokens of the current user\ncurl -H 'Authorization: Bearer &lt;OIDC-Or-API_TOKEN&gt;' \\\n-H 'Content-Type: application/json' \\\n-X DELETE https://&lt;URL-to-AOS-instance-API-gateway&gt;/v1/auth/tokens\n</code></pre> <pre><code>// Create tonic/ArunaAPI request to revoke the specific API token\nlet delete_request = DeleteApiTokenRequest {\ntoken_id: \"&lt;token-id&gt;\".to_string(),\n};\n// Send the request to the AOS instance gRPC gateway\nlet response = user_client.delete_api_token(delete_request)\n.await\n.unwrap()\n.into_inner();\n// Do something with the response\nprintln!(\"{:#?}\", response);\n</code></pre> <pre><code>// Create tonic/ArunaAPI request to to revoke all tokens of the current user\nlet delete_request = DeleteApiTokensRequest {\nuser_id: \"\".to_string(),\n};\n// Send the request to the AOS instance gRPC gateway\nlet response = user_client.delete_api_tokens(delete_request)\n.await\n.unwrap()\n.into_inner();\n// Do something with the response\nprintln!(\"{:#?}\", response);\n</code></pre>"},{"location":"internal_data_structure/database_erd/","title":"Database ERD","text":"Aruna Object Storage (AOS) database entity-relationship diagram. Click for zoom."},{"location":"internal_data_structure/internal_data_structure/","title":"Internal Data Structure","text":""},{"location":"internal_data_structure/internal_data_structure/#project","title":"Project","text":"<p>Basic resource to organize general user access for all collections registered in the project. A project also acts as an umbrella container for one or multiple collections and has to be available before collection creation is possible.</p>"},{"location":"internal_data_structure/internal_data_structure/#collection","title":"Collection","text":"<p>Basic resource to organize stored data i.e. Objects. Collections can be described with more detailed metadata by registering one or multiple Object/s marked as \"specification\" of the Collection.</p> <p>Collections can also be versioned on-demand with a version number following semantic versioning principles. On creation of a collection version the collection a shallow cloned and immutable copy of the collection is created. The version number is defined manually by the user who pinpoints the Collection.</p>"},{"location":"internal_data_structure/internal_data_structure/#object","title":"Object","text":"<p>Resource which fundamentally stores the data in the backend storage system. An Object can only be owned by one collection at a time but references can be created for multiple collections. Depending on the context an Object can represent data or metadata. Additionally, an Object has revisions</p>"},{"location":"internal_data_structure/internal_data_structure/#state-system","title":"State system","text":"<p>Objects in the storage have states. These are used to indicate the status of an Object during its lifecycle.</p> <ul> <li>INITIALIZING: After Object creation/initialization but before Object finishing.</li> <li>AVAILABLE: After Object finishing if everything succeeded.</li> <li>UNAVAILABLE: E.g. while an Object is being updated or generally in the staging area.</li> <li>ERROR: If something went wrong e.g. data proxy endpoints are down.</li> <li>TRASH: Object was deleted and waits to be removed by the garbage collector.</li> <li>DELETED: Object was removed by the garbage collector but is still referenced by another Object.</li> </ul>"},{"location":"internal_data_structure/internal_data_structure/#labelhook-optional","title":"Label/Hook [optional]","text":"<p>Simple resource which represents a key-value pair which is directly associated with a Collection, Object or ObjectGroup.</p> Labels Used to describe short properties of the resource with which it is associated. Hooks Used to reference (external) services which automatically process/validate/... the data upon registration."},{"location":"internal_data_structure/internal_data_structure/#objectgroup-optional","title":"ObjectGroup [optional]","text":"<p>ObjectGroups are a secondary resource to organize Objects inside Collections.</p>"}]}